var PGSet = require('pg-classes/pgset');

function newDeal(gameHash, dealIndex) {

    console.log('pg.newDeal(' + gameHash + ', ' + dealIndex + ')');

    // Create a deck of tile indices
    var tiles = [], ti, gi;
    for (ti = 0; ti < 32; ti++) tiles.push(ti);

    // Seed the random number by running it a number of times based
    // on gameHash and dealIndex.
    var numTimes = dealIndex;
    for (gi = gameHash.length-1; gi >=0; gi--) {
        numTimes += gameHash.charCodeAt(gi) * gi;
    }
    console.log('numTimes: ' + numTimes);
    while (numTimes--) Math.random();

    // Shuffle the deck.
    var washed = [];
    for (var index = 0; index < 32; index++) {
        value = tiles[index];
        if (index === 0) {
            washed[0] = value;
        } else {
            rand = Math.floor(Math.random() * (index + 1));
            washed[index] = washed[rand];
            washed[rand] = value;
        }
    }

    var situation = {};
    return {
        'dealID': gameHash + '#' + dealIndex,
        'situation': {
            'player': 'TILES_NOT_SET',
            'opponent': 'TILES_NOT_SET'
        },
        'points': [ 0, 0, 0 ],
        'tiles': washed.slice(0, 24)
    };
}

// function setTilesForDeal(pgDeal) {
//     console.log('Setting tiles for deal');
//     var params = {
//       FunctionName: 'STRING_VALUE', /* required */
//       ClientContext: 'STRING_VALUE',
//       InvocationType: 'Event | RequestResponse | DryRun',
//       LogType: 'None | Tail',
//       Payload: new Buffer('...') || 'STRING_VALUE',
//       Qualifier: 'STRING_VALUE'
//     };
//     lambda.invoke(params, function(err, data) {
//       if (err) console.log(err, err.stack); // an error occurred
//       else     console.log(data);           // successful response
//     });
// }

function addPointsToDeal(deal) {
    console.log('looking to score deal');
    if (deal.situation.player === 'TILES_ARE_SET' &&
            deal.situation.opponent === 'TILES_ARE_SET') {
        var ih;
        console.log('both players have set their tiles, scoring deal');
        deal.points = [];
        deal.handpoints = [];
        for (ih = 0; ih < 3; ih++) {
            var pStart = ih * 4,
                oStart = pStart + 12,
                pSet = new PGSet(deal.tiles.slice(pStart, pStart + 4)),
                oSet = new PGSet(deal.tiles.slice(oStart, oStart + 4));
                comp = pSet.compare(oSet);
            console.log('scoring for ' + (ih + 1) + ' points:');
            console.log('   player: ' + pSet.toString());
            console.log(' opponent: ' + oSet.toString());
            if (comp > 0) {
                deal.points.push(3-ih);
                console.log('    ...player wins');
            } else if (comp < 0) {
                deal.points.push(-(3-ih));
                console.log('    ...opponent wins');
            } else {
                deal.points.push(0);
                console.log('    ...push');
            }

            // Push the detail W/L/P for each hand.
            deal.handpoints.push(pSet.compareEx(oSet));
        }
    } else {
        console.log('one or both players are not ready to score.');
    }
    return deal;
}


module.exports = {
    newDeal: newDeal,
    addPointsToDeal: addPointsToDeal
};
