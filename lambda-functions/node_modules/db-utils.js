// DB utility functions
var q = require('q'),
    aws = require('aws-sdk');

function getDynamoDB() {
    if (process.env.AWS_ENDPOINT) {
        aws.config.update({
            region: "us-west-2",
            endpoint: process.env.AWS_ENDPOINT
        });
    }
    var ddbdoc = require('dynamodb-doc');
    return new (ddbdoc).DynamoDB();
}

// We need to use a table, make sure it's up and available.
function verifyDescribeTable(dynamodb, tableName, successResolveArg) {
    var defer = q.defer(),
        response;

    console.log('verifyDescribeTable: ' + tableName);

    // Make sure there is an active table
    dynamodb.describeTable({ TableName: tableName }, function(err, data) {
        if (err) {
            // It should have been created, something is wrong.
            console.log('describeTable(' + tableName + ') returned error: ' + JSON.stringify(err));
            response = {
                error: 'Cannot describe ' + tableName + ' table',
                code: 'PG_ERROR_DB_DESCRIBE'
            };
            defer.reject(response);
        } else if (!data || !data.Table || !data.Table.TableStatus) {
            // It should have been created, something is wrong.
            console.log('describeTable(' + tableName + ') returned no error, but no TableStatus ether');
            response = {
                error: 'Cannot describe ' + tableName + ' table',
                code: 'PG_ERROR_DB_DESCRIBE_GIBBERISH'
            };
            defer.reject(response);
        } else if (data.Table.TableStatus !== 'ACTIVE') {
            // It should have been created, something is wrong.
            console.log('describeTable(' + tableName + ') returned inactive table');
            response = {
                error: 'Table(' + tableName + ') not active',
                code: 'PG_ERROR_DB_DESCRIBE_NOT_ACTIVE'
            };
            defer.reject(response);
        } else {
            console.log('verifyDescribeTable resolving');
            defer.resolve(successResolveArg);
        }
    });

    return defer.promise;
}

function validateSession(dynamodb, sessionHash) {
    var startTime = new Date().getTime(),
        defer = q.defer(),
        self = this,
        response;

    console.log('validateSession: ' + sessionHash);

    if (!sessionHash) {
        console.log('Session cannot be validated: User is not logged in');
        response = {
            error: 'You must be logged in to perform this action',
            code: 'PG_ERROR_NO_SESSION'
        };
        defer.reject(response);
    } else {
        this.getItem(dynamodb, 'session', 'sessionHash', sessionHash)
        .then(function(session) {
            if (!session || session.sessionHash !== sessionHash) {
                console.log('validateSession(' + sessionHash + ') failed, no match');
                response = {
                    error: 'Cannot get session',
                    code: 'PG_ERROR_DB_SESSION_NOT_FOUND'
                };
                defer.reject(response);
            } else {
                console.log('Got session, putting date in');
                // Update the last-used time.  If we fail no biggie.
                var date = new Date();
                session.lastLoginTime = date.getTime();
                console.log('Got session, putting date of ' + session.lastLoginTime);
                self.putItem(dynamodb, 'session', session)
                .finally(function() {
                    console.log('validateSession elapsed time: ' + ((new Date().getTime()) - startTime) + ' msec');
                    defer.resolve(session);
                });
            }

        })
        .fail(function(err) {
            defer.reject(err);
        });
    }

    return defer.promise;
}

// Return the situation for a player.  If they're supposedly LOGGED_IN,
// but it's been more than 15 minutes since they've played, then they're
// actually logged out.
function playerSituation(dynamodb, player) {
    var startTime = new Date().getTime(),
        defer = q.defer(),
        playerName = player.username;
    console.log('player situation for ' + playerName);

    if (player.situation !== 'LOGGED_IN') {
        // Player isn't logged in: believe them.
        console.log('player "' + playerName + '" not logged in, returning "' + player.situation + '"');
        console.log('playerSituation elapsed time: ' + ((new Date().getTime()) - startTime) + ' msec');
        defer.resolve(player.situation);

    } else if (player.sessionHash === '*') {
        // Computer is always logged in: sessionHash is '*'
        console.log('computer is always logged in');
        console.log('playerSituation elapsed time: ' + ((new Date().getTime()) - startTime) + ' msec');
        defer.resolve('LOGGED_IN');

    } else if (!player.sessionHash) {
        // No session hash for logged-in player: odd... but they can't be logged in.
        console.log('player "' + playerName + '" does not have sessionHash, must be logged out');
        console.log('playerSituation elapsed time: ' + ((new Date().getTime()) - startTime) + ' msec');
        defer.resolve('LOGGED_OUT');

    } else {
        // Player claims to be logged in, and they have a session: check it for inactivity.        
        console.log('player "' + playerName + '" says logged in, checking session');
        this.getItem(dynamodb, 'session', 'sessionHash', player.sessionHash)
        .then(function(session) {
            console.log('player "' + playerName + '" looking at session');

            // No date means it's very old (before date-logging) so logged out.
            if (!session.lastLoginTime) {
                console.log('player "' + playerName + '" session without last login, returning LOGGED_OUT');
                console.log('playerSituation elapsed time: ' + ((new Date().getTime()) - startTime) + ' msec');
                defer.resolve('LOGGED_OUT');

            } else {
                // Session has a last-login: check how long ago it was.
                var curTime = new Date().getTime();
                if ((curTime - session.lastLoginTime) > (15 * 60 * 1000)) {
                    console.log('player "' + playerName + '" session says no activity for > 15 min, returning LOGGED_OUT');
                    console.log('playerSituation elapsed time: ' + ((new Date().getTime()) - startTime) + ' msec');
                    defer.resolve('LOGGED_OUT');
                }

                // Everything is good.
                console.log('player "' + playerName + '" session has recent activity, returning LOGGED_IN');
                console.log('playerSituation elapsed time: ' + ((new Date().getTime()) - startTime) + ' msec');
                defer.resolve('LOGGED_IN');
            }
        })
        .fail(function(err) {
            console.log('playerSituation FAIL: ' + err);
            // Tried to get a session and failed.  Must be logged out.
            defer.resolve('LOGGED_OUT');
        });
    }

    return defer.promise;
}

function validatePlayer(dynamodb, sessionHash) {
    var self = this;
    console.log('validatePlayer with sessionHash: ' + sessionHash);
    return this.validateSession(dynamodb, sessionHash)
    .then(function(session) {
        console.log('validatePlayer got session, getting player "' + session.username + '"');
        return self.getItem(dynamodb, 'player', 'username', session.username);
    });
}

function getItem(dynamodb, tableName, keyName, keyValue) {
    var startTime = new Date().getTime(),
        defer = q.defer(),
        response,
        params = { TableName: tableName, Key: {}};

    params.Key[keyName] = keyValue;

    console.log('getItem from table ' + tableName);
    console.log(JSON.stringify(params));

    dynamodb.getItem(params, function(err, data) {
        var startTime = new Date().getTime();
        if (err) {
            console.log('getItem from table "' + tableName + '" returned error: ' + JSON.stringify(err));
            response = {
                error: 'Cannot get item from table ' + tableName,
                code: 'PG_ERROR_DB_GET_' + tableName.toUpperCase()
            };
            defer.reject(response);
        } else  if (!data) {
            console.log('getItem from table "' + tableName + '" returned no data');
            response = {
                error: 'Cannot get session',
                code: 'PG_ERROR_DB_GET_' + tableName.toUpperCase() + '_GIBBERISH'
            };
            defer.reject(response);
        } else {
            console.log('getItem from table "' + tableName + '" resolved with item');
            console.log('data: ' + JSON.stringify(data));
            console.log('getItem elapsed time: ' + ((new Date().getTime()) - startTime) + ' msec');
            defer.resolve(data.Item || {});
        }
    });

    return defer.promise;
}

function putItem(dynamodb, tableName, item) {
    var startTime = new Date().getTime(),
        defer = q.defer(),
        response,
        params = { TableName: tableName, Item: item};

    console.log('putItem into table ' + tableName);
    console.log(JSON.stringify(item));

    dynamodb.putItem(params, function(err, data) {
        if (err) {
            console.log('Cannot put item into table ' + tableName + ': ' + JSON.stringify(err));
            response = {
                error: 'Cannot write to table ' + tableName,
                code: 'PG_ERROR_DB_PUTITEM'
            };
            defer.reject(response);
        } else {
            console.log('putItem elapsed time: ' + ((new Date().getTime()) - startTime) + ' msec');
            defer.resolve();
        }
    });

    return defer.promise;
}

module.exports = {
    getDynamoDB: getDynamoDB,

    getItem: getItem,
    putItem: putItem,

    verifyDescribeTable: verifyDescribeTable,
    validateSession: validateSession,
    validatePlayer: validatePlayer,

    playerSituation: playerSituation
};

